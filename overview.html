<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-08-01T14:13:13.1032221"><title>Overview | FooocusAPI</title><script type="application/json" id="virtual-toc-data">[{"id":"how-about-fooocus-work","level":0,"title":"How about Fooocus work","anchor":"#how-about-fooocus-work"},{"id":"thinking-when-reconstructing","level":0,"title":"Thinking When Reconstructing","anchor":"#thinking-when-reconstructing"},{"id":"how-about-fooocusapi-work","level":0,"title":"How about FooocusAPI work","anchor":"#how-about-fooocusapi-work"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b408/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Overview | FooocusAPI"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="FooocusAPI Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/docs/en_us/overview.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Overview | FooocusAPI"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/docs/en_us/overview.html#webpage",
    "url": "writerside-documentation/docs/en_us/overview.html",
    "name": "Overview | FooocusAPI",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/docs/#website",
    "url": "writerside-documentation/docs/",
    "name": "FooocusAPI Help"
}</script><!-- End Schema.org --></head><body data-id="Overview" data-main-title="Overview" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>FooocusAPI en_us Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Overview" id="Overview.md">Overview</h1><p id="az7q0m_3">FooocusAPI is a refactor of <a href="https://github.com/mrhan1993/Fooocus-API" id="az7q0m_8" data-external="true" rel="noopener noreferrer">Fooocus-API</a>, they are both the secondary development of <a href="https://github.com/lllyasviel/Fooocus" id="az7q0m_9" data-external="true" rel="noopener noreferrer">Fooocus</a>. It is used to solve the problem that the API call of Gradio in the original project is difficult to understand and difficult to meet the use of Fooocus as a service deployment.</p><aside class="prompt" data-type="tip" data-title="" id="az7q0m_4"><p id="az7q0m_10">As this project is a branch of Fooocus, so the document will have some content directly taken from Fooocus document, and there are many references to it.</p></aside><section class="chapter"><h2 id="how-about-fooocus-work" data-toc="how-about-fooocus-work">How about Fooocus work</h2><p id="az7q0m_11">When you start reading the code of Fooocus, you will find that most of the main logic of the parameters, task management, etc. are concentrated in the <a href="https://github.com/lllyasviel/Fooocus/blob/main/modules/async_worker.py" id="az7q0m_32" data-external="true" rel="noopener noreferrer">async_worker.py</a> file.</p><aside class="prompt" data-type="tip" data-title="" id="az7q0m_12"><p id="az7q0m_33">Next is my personal understanding of the code, which does not represent the official Fooocus, and is for reference only. And only the basic execution flow is designed, not the more low-level model inference part.</p></aside><p id="az7q0m_13">Because <a href="https://github.com/lllyasviel/Fooocus/releases/tag/v2.5.0" id="az7q0m_34" data-external="true" rel="noopener noreferrer">Fooocus v2.5.0</a> refactored this file, so here is a brief explanation of the work logic of this file at 2.4.3:</p><p id="az7q0m_14">First，a class <code class="code" id="az7q0m_35">AsyncTask</code> is defined to instantiate task objects</p><div class="code-block" data-lang="python">
class AsyncTask:
    def __init__(self, args):
        self.args = args
        self.yields = []
        self.results = []
        self.last_stop = False
        self.processing = False
</div><ul class="list _bullet" id="az7q0m_16"><li class="list__item" id="az7q0m_36"><p><code class="code" id="az7q0m_41">args</code>: Used for store task parameters, it is a list, which contains the information submitted by the user from WebUI</p></li><li class="list__item" id="az7q0m_37"><p><code class="code" id="az7q0m_42">yields</code>: Used for storing the progress, intermediate results, and preview images generated during the task execution. It is a list</p></li><li class="list__item" id="az7q0m_38"><p><code class="code" id="az7q0m_43">results</code> ：Used for store the final result of the task, it is a list, and will contain the local path of the generated image</p></li><li class="list__item" id="az7q0m_39"><p><code class="code" id="az7q0m_44">last_stop</code> ：Used for record the last stop status of the task, which can be <code class="code" id="az7q0m_45">skip</code> or <code class="code" id="az7q0m_46">stop</code>, and will be checked in the loop of the task execution</p></li><li class="list__item" id="az7q0m_40"><p><code class="code" id="az7q0m_47">processing</code> ：Used for record the current status of the task, if it is True, it means that the task is being executed</p></li></ul><p id="az7q0m_17">And then, defined a list <code class="code" id="az7q0m_48">async_tasks = []</code>, which is a queue of tasks to be executed, and there is a loop that will try to take tasks from it and execute them.</p><p id="az7q0m_18">Next is a long 1000-line method <code class="code" id="az7q0m_49">worker</code>, most of which are various parameter processing, but no problem, we start from the beginning one by one.</p><p id="az7q0m_19">When a task is submitted, the information submitted by the user from WebUI will be instantiated as a task object and added to the <code class="code" id="az7q0m_50">async_tasks</code> list, the process is in the 50th line of <code class="code" id="az7q0m_51">webui.py</code>, next, the loop that checks the <code class="code" id="az7q0m_52">async_tasks</code> list will take the task and execute it. This code is located at the end of <code class="code" id="az7q0m_53">async_tasks.py</code>:</p><div class="code-block" data-lang="python">
while True:
    time.sleep(0.01)
    if len(async_tasks) &gt; 0:
        task = async_tasks.pop(0)
        generate_image_grid = task.args.pop(0)

        try:
            handler(task)
            if generate_image_grid:
                build_image_wall(task)
            task.yields.append(['finish', task.results])
            pipeline.prepare_text_encoder(async_call=True)
        except:
            traceback.print_exc()
            task.yields.append(['finish', task.results])
        finally:
            if pid in modules.patch.patch_settings:
                del modules.patch.patch_settings[pid]
</div><p id="az7q0m_21">After task is taken, it will be passed to <code class="code" id="az7q0m_54">handler</code> for processing (135 line)</p><p id="az7q0m_22">First, <code class="code" id="az7q0m_55">handler</code> will take all the parameters and do some preliminary processing, this part end at 220 line</p><p id="az7q0m_23">Next, there is further processing of the parameters, such as case conversion, determining the number of steps based on the selected performance, adjusting the model, lora, and corresponding other parameters, and performing possible model downloads, which should be done around line 343</p><p id="az7q0m_24">And then defined two list: <code class="code" id="az7q0m_56">goals = []</code> and <code class="code" id="az7q0m_57">tasks = []</code>, They are respectively used to store image processing labels, i.e <code class="code" id="az7q0m_58">uov</code> <code class="code" id="az7q0m_59">inpaint</code> <code class="code" id="az7q0m_60">ip</code>, <code class="code" id="az7q0m_61">tasks</code> Used to split tasks, when <code class="code" id="az7q0m_62">image_number &gt; 1</code> the task will be split into multiple tasks, and the <code class="code" id="az7q0m_63">tasks</code> list will be used to store the split tasks</p><p id="az7q0m_25">Next, depending on whether <code class="code" id="az7q0m_64">input_image</code> is checked, this part of the code is executed. Its function is to add markers to the <code class="code" id="az7q0m_65">goals</code> list based on the current <code class="code" id="az7q0m_66">tab</code> and the checked status of <code class="code" id="az7q0m_67">mixing_image_prompt_and_vary_upscale</code> and <code class="code" id="az7q0m_68">mixing_image_prompt_and_inpaint</code>. At the same time, various uploaded images are preprocessed and possible model downloads are performed. This section is located approximately at lines <code class="code" id="az7q0m_69">348-422</code>.</p><p id="az7q0m_26">Regardless of whether <code class="code" id="az7q0m_70">input_image</code> is checked or not, the code will proceed to the <code class="code" id="az7q0m_71">skip_prompt_processing</code> judgment after a brief loading of the model and overlay of parameters. This logic is located at lines <code class="code" id="az7q0m_72">448-549</code>. Its function is to expand the description words and reverse description words based on the selected <code class="code" id="az7q0m_73">styles</code> for model optimization.</p><p id="az7q0m_27">What follows is a series of processing steps based on the content of <code class="code" id="az7q0m_74">goals</code>. Apart from <code class="code" id="az7q0m_75">upscale fast</code>, which will return the result directly, the other situations are still processed in stages until line 868, where the <code class="code" id="az7q0m_76">tasks</code> list is iterated over. If everything goes smoothly, the final processing will be done here, such as formatting metadata, saving files, and returning the results.</p><p id="az7q0m_28">Throughout the entire process, the status of task execution is continuously updated through the <code class="code" id="az7q0m_77">yields</code> property of the task object. By using the <code class="code" id="az7q0m_78">callback</code> function, we can clearly see the storage structure in the list:</p><div class="code-block" data-lang="python">
def callback(step, x0, x, total_steps, y):
    done_steps = current_task_id * steps + step
    async_task.yields.append(['preview', (
        int(flags.preparation_step_count + (100 - flags.preparation_step_count) * float(done_steps) / float(all_steps)),
        f'Sampling step {step + 1}/{total_steps}, image {current_task_id + 1}/{image_number} ...', y)])
</div><p id="az7q0m_30">After a simple calculation, a list similar to the following will be obtained: <code class="code" id="az7q0m_79">['preview', (60, 'Sample step 60/100, image 1/1 ...', y)]</code>. The meaning of the elements in this list is as follows:</p><ul class="list _bullet" id="az7q0m_31"><li class="list__item" id="az7q0m_80"><p><code class="code" id="az7q0m_82">preview</code> ：This is similar to a phase identifier, and the information it can provide is limited.</p></li><li class="list__item" id="az7q0m_81"><p>Tuple： </p><ul class="list _bullet" id="az7q0m_83"><li class="list__item" id="az7q0m_84"><p>60: The progress, which is easy to understand, refers to the overall progress.</p></li><li class="list__item" id="az7q0m_85"><p>'Sample step 60/100, image 1/1 ...': The description of the current step</p></li><li class="list__item" id="az7q0m_86"><p>y：This refers to the image for each step, which means that using this, you can see the process of an image being generated.</p></li></ul></li></ul></section><section class="chapter"><h2 id="thinking-when-reconstructing" data-toc="thinking-when-reconstructing">Thinking When Reconstructing</h2><p id="az7q0m_87">In the <a href="https://github.com/mrhan1993/Fooocus-API" id="az7q0m_94" data-external="true" rel="noopener noreferrer">Fooocus-API</a> project created by <a href="https://github.com/konieshadow" id="az7q0m_95" data-external="true" rel="noopener noreferrer">konieshadow</a>, he implemented a new task queue and built new task objects based on FastAPI. Then, by rewriting some of the logic in <code class="code" id="az7q0m_96">async_worker.py</code>, he completed the development of Fooocus-API.</p><p id="az7q0m_88">After taking over and maintaining the project for half a year, the issues caused by this processing method have become increasingly difficult to handle. The main problems are the following two:</p><ol class="list _decimal" id="az7q0m_89" type="1"><li class="list__item" id="az7q0m_97"><p>When dealing with updates to the Fooocus version, it is necessary to synchronously update the code in <code class="code" id="az7q0m_99">async_worker.py</code>. As a generator, one must be careful to handle each change.</p></li><li class="list__item" id="az7q0m_98"><p>The startup of the project is based on the premise of starting a FastAPI service, which prevents the reuse of the pre-startup logic in Fooocus and requires reimplementation. This includes tasks such as dependency installation, environment detection, configuration file reading, etc. Although these can be achieved through simple code duplication.</p></li></ol><p id="az7q0m_90">Additionally, there are some historical minor issues, such as:</p><ul class="list _bullet" id="az7q0m_91"><li class="list__item" id="az7q0m_100"><p>Inability to use WebUI simultaneously.</p></li><li class="list__item" id="az7q0m_101"><p>Need to request a separate EndPoint to obtain progress images.</p></li><li class="list__item" id="az7q0m_102"><p>Incomplete persistence of task information and inconsistent return data formats.</p></li></ul><p id="az7q0m_92">Based on the above issues, I have decided to refactor Fooocus-API with the following approach:</p><ol class="list _decimal" id="az7q0m_93" type="1"><li class="list__item" id="az7q0m_103"><p>Utilize the task handling logic in <code class="code" id="az7q0m_106">async_worker.py</code>, with the API solely responsible for receiving parameters and passing them to the task handling logic.</p></li><li class="list__item" id="az7q0m_104"><p>Abandon the separately maintained queue and reuse the queue in <code class="code" id="az7q0m_107">async_worker.py</code>.</p></li><li class="list__item" id="az7q0m_105"><p>Merge interface functions, since all parameters are ultimately processed through the <code class="code" id="az7q0m_108">handler</code> function in <code class="code" id="az7q0m_109">async_worker.py</code>, the API only needs to be responsible for receiving parameters and passing them on. Separate interfaces are unnecessary.</p></li></ol></section><section class="chapter"><h2 id="how-about-fooocusapi-work" data-toc="how-about-fooocusapi-work">How about FooocusAPI work</h2><p id="az7q0m_110">So, I redesigned the structure of FooocusAPI.</p><p id="az7q0m_111">Add a method in <code class="code" id="az7q0m_118">webui.py</code> to start the API service and WebUI, at this time, we can use WebUI and API service at the same time</p><div class="code-block" data-lang="python">
def run_gradio():
    &quot;&quot;&quot;
    Run the gradio interface
    &quot;&quot;&quot;
    shared.gradio_root.launch(
        inbrowser=args_manager.args.in_browser,
        server_name=args_manager.args.listen,
        server_port=args_manager.args.port,
        share=args_manager.args.share,
        auth=check_auth if (args_manager.args.share or args_manager.args.listen) and auth_enabled else None,
        allowed_paths=[modules.config.path_outputs],
        blocked_paths=[constants.AUTH_FILENAME]
    )


if not args_manager.args.nowebui:
    Thread(target=run_gradio, daemon=True).start()
run_server(args_manager.args)
</div><p id="az7q0m_113">And then, put all the parameters into a model <a href="https://github.com/mrhan1993/FooocusAPI/blob/main/apis/models/requests.py" id="az7q0m_119" data-external="true" rel="noopener noreferrer"><code class="code" id="az7q0m_120">CommonRequest</code></a></p><p id="az7q0m_114">After that, I added a new function <a href="https://github.com/mrhan1993/FooocusAPI/blob/main/apis/utils/pre_process.py" id="az7q0m_121" data-external="true" rel="noopener noreferrer"><code class="code" id="az7q0m_122">pre_process</code></a>, which is used to preprocess the parameters, e.g. convert params, save image, download model, etc.</p><p id="az7q0m_115">And then, use <a href="https://github.com/mrhan1993/FooocusAPI/blob/main/apis/utils/api_utils.py" id="az7q0m_123" data-external="true" rel="noopener noreferrer"><code class="code" id="az7q0m_126">api_utils</code></a> to process the parameters, and add it to <code class="code" id="az7q0m_124">async_tasks</code> list in <a href="https://github.com/mrhan1993/FooocusAPI/blob/main/modules/async_worker.py" id="az7q0m_125" data-external="true" rel="noopener noreferrer"><code class="code" id="az7q0m_127">async_worker.py</code></a></p><p id="az7q0m_116">In the end, <a href="https://github.com/mrhan1993/FooocusAPI/blob/main/apis/utils/call_worker.py" id="az7q0m_128" data-external="true" rel="noopener noreferrer"><code class="code" id="az7q0m_129">call_worker</code></a> will monitor the execution status of the task and return different results based on different parameters when the task is completed.</p><p id="az7q0m_117">After the refactoring is completed, the original functionality will be preserved to the maximum extent possible, while also allowing API services to coexist with WebUI. Although modifications to <code class="code" id="az7q0m_130">asyncw_worker.py</code> are still required for features that are not available in Fooocus, such as custom magnification and support for Outpaint customization, the amount of modifications has been greatly reduced. Additionally, due to the limited modifications made to Fooocus, the maintenance cost of the API is greatly reduced in the absence of major version changes, making it easier to track updates to Fooocus. For minor updates, simply merging upstream code is sufficient.</p></section><div class="last-modified">Last modified: 01 八月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="requirement.html" class="navigation-links__next">Requirement</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b408/app.js"></script></body></html>