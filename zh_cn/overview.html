<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-08-03T17:27:41.9176507"><title>概述 | FooocusAPI</title><script type="application/json" id="virtual-toc-data">[{"id":"how-about-fooocus-work","level":0,"title":"How about Fooocus work","anchor":"#how-about-fooocus-work"},{"id":"thinking-when-reconstructing","level":0,"title":"Thinking When Reconstructing","anchor":"#thinking-when-reconstructing"},{"id":"how-about-fooocusapi-work","level":0,"title":"How about FooocusAPI work","anchor":"#how-about-fooocusapi-work"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b408/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="概述 | FooocusAPI"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="FooocusAPI Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/docs/zh_cn/overview.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="概述 | FooocusAPI"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/docs/zh_cn/overview.html#webpage",
    "url": "writerside-documentation/docs/zh_cn/overview.html",
    "name": "概述 | FooocusAPI",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/docs/#website",
    "url": "writerside-documentation/docs/",
    "name": "FooocusAPI Help"
}</script><!-- End Schema.org --></head><body data-id="Overview" data-main-title="概述" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>FooocusAPI zh_cn Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Overview" id="Overview.md">概述</h1><p id="-cowyly_3">FooocusAPI 是对 <a href="https://github.com/mrhan1993/Fooocus-API" id="-cowyly_8" data-external="true" rel="noopener noreferrer">Fooocus-API</a> 项目的重构，它们都是对 <a href="https://github.com/lllyasviel/Fooocus" id="-cowyly_9" data-external="true" rel="noopener noreferrer">Fooocus</a> 项目的二次开发， 旨在解决原项目中 Gradio 的 API 调用难以理解，且难以满足将 Fooocus 作为服务部署时的使用问题。</p><aside class="prompt" data-type="tip" data-title="" id="-cowyly_4"><p id="-cowyly_10">由于该项目属于 Fooocus 分支，因此文档会有部分内容直接取自 Fooocus 文档，且对其有许多参考。</p></aside><section class="chapter"><h2 id="how-about-fooocus-work" data-toc="how-about-fooocus-work">How about Fooocus work</h2><p id="-cowyly_11">当你开始阅读 Fooocus 的代码时很容易发现，其对于参数的处理、任务管理等主要逻辑都集中于 <a href="https://github.com/lllyasviel/Fooocus/blob/main/modules/async_worker.py" id="-cowyly_33" data-external="true" rel="noopener noreferrer">async_worker.py</a> 这个文件。</p><aside class="prompt" data-type="tip" data-title="" id="-cowyly_12"><p id="-cowyly_34">以下内容为本人阅读项目代码后的个人理解，不代表 Fooocus 官方，仅供参考。并且只设计基础的执行流程，不包括更加底层的模型推理部分。</p></aside><p id="-cowyly_13">由于 <a href="https://github.com/lllyasviel/Fooocus/releases/tag/v2.5.0" id="-cowyly_35" data-external="true" rel="noopener noreferrer">Fooocus v2.5.0</a> 对该文件进行了重构，因此这里以 2.4.3 为例简要说明该文件的工作逻辑：</p><p id="-cowyly_14">首先，该文件定义了一个 <code class="code" id="-cowyly_36">AsyncTask</code> 类，它用来实例化任务对象</p><div class="code-block" data-lang="python">
class AsyncTask:
    def __init__(self, args):
        self.args = args
        self.yields = []
        self.results = []
        self.last_stop = False
        self.processing = False
</div><ul class="list _bullet" id="-cowyly_16"><li class="list__item" id="-cowyly_37"><p><code class="code" id="-cowyly_42">args</code> ：用于存储任务参数，它是一个列表，包含用户从 WebUI 提交来的信息</p></li><li class="list__item" id="-cowyly_38"><p><code class="code" id="-cowyly_43">yields</code> ：用于存储任务执行过程中产生的中间结果，它是一个列表，会包含进度、正在执行的操作、预览图信息</p></li><li class="list__item" id="-cowyly_39"><p><code class="code" id="-cowyly_44">results</code> ：用于存储任务执行完成后产生的结果，它是一个列表，会包含生成的图片的本地路径</p></li><li class="list__item" id="-cowyly_40"><p><code class="code" id="-cowyly_45">last_stop</code> ：用于记录任务中断信息，可以是 skip, stop，在任务执行的循环中会一直检查该属性</p></li><li class="list__item" id="-cowyly_41"><p><code class="code" id="-cowyly_46">processing</code> ：用于记录任务是否正在执行，如果为 True 则表示任务正在执行</p></li></ul><p id="-cowyly_17">然后，定义了一个列表 <code class="code" id="-cowyly_47">async_tasks = []</code> ，该列表作为一个待执行任务的队列，有一个死循环会尝试从中拿取任务并执行</p><p id="-cowyly_18">接下来是一个长达一千行的方法 <code class="code" id="-cowyly_48">worker</code> ，这其中绝大部分是对于参数的各种处理，但是没有关系，我们一点点从头开始。</p><p id="-cowyly_19">当一个任务被提交，也即 WebUI 上的 Generate 按钮被按下时，从 WebUI 上提交的信息会首先被实例化为一个 task 对象并添加到 <code class="code" id="-cowyly_49">async_tasks</code> 列表中， 这个过程在 <code class="code" id="-cowyly_50">webui.py</code> 的第 50 行，</p><p id="-cowyly_20">之后，一直对 <code class="code" id="-cowyly_51">async_tasks</code> 列表进行循环检查的循环会拿取这个任务，这部分代码位于 <code class="code" id="-cowyly_52">async_tasks.py</code> 的末尾：</p><div class="code-block" data-lang="python">
while True:
    time.sleep(0.01)
    if len(async_tasks) &gt; 0:
        task = async_tasks.pop(0)
        generate_image_grid = task.args.pop(0)

        try:
            handler(task)
            if generate_image_grid:
                build_image_wall(task)
            task.yields.append(['finish', task.results])
            pipeline.prepare_text_encoder(async_call=True)
        except:
            traceback.print_exc()
            task.yields.append(['finish', task.results])
        finally:
            if pid in modules.patch.patch_settings:
                del modules.patch.patch_settings[pid]
</div><p id="-cowyly_22">任务被拿取之后被传递给了 <code class="code" id="-cowyly_53">handler</code> 处理（135行开始）</p><p id="-cowyly_23">首先， <code class="code" id="-cowyly_54">handler</code> 将所有参数取出，并对部分参数进行了初步的整理，这部分大概到 220 行结束</p><p id="-cowyly_24">接下来，是对参数的进一步处理，比如大小写转换、根据选择的 <code class="code" id="-cowyly_55">performance</code> 确定步数、模型、lora以及对应的其他参数的调整，进行可能的模型下载，这大概到 343 行</p><p id="-cowyly_25">然后是两个列表的定义： <code class="code" id="-cowyly_56">goals = []</code> 和 <code class="code" id="-cowyly_57">tasks = []</code> ，它们分别用于存储图像处理标记也即 <code class="code" id="-cowyly_58">uov</code> <code class="code" id="-cowyly_59">inpaint</code> <code class="code" id="-cowyly_60">ip</code>， <code class="code" id="-cowyly_61">tasks</code> 则用于出处拆分任务，当 <code class="code" id="-cowyly_62">image_number &gt; 1</code> 时，会被拆分并暂存于此</p><p id="-cowyly_26">接下来，根据是否勾选了 <code class="code" id="-cowyly_63">input_image</code> 执行该部分代码，其作用是根据当前所在的 <code class="code" id="-cowyly_64">tab</code> 以及 <code class="code" id="-cowyly_65">mixing_image_prompt_and_vary_upscale</code> 和 <code class="code" id="-cowyly_66">mixing_image_prompt_and_inpaint</code> 的勾选情况向 <code class="code" id="-cowyly_67">goals</code> 列表增加标记，同时上传的各种图像进行预处理、以及可能的模型下载。这部分大概位于 <code class="code" id="-cowyly_68">348-422</code> 行</p><p id="-cowyly_27">无论是否勾选 <code class="code" id="-cowyly_69">input_image</code> 都会在一个短暂的加载模型和覆盖参数之后进入到 <code class="code" id="-cowyly_70">skip_prompt_processing</code> 的判断。这个逻辑位于 <code class="code" id="-cowyly_71">448-549</code> 行，其作用是对描述词、反向描述词 根据选择的 <code class="code" id="-cowyly_72">styles</code> 进行展开，模型优化</p><p id="-cowyly_28">接下来的是根据 <code class="code" id="-cowyly_73">golas</code> 中的内容进行的一系列处理。除开 upscale fast 会直接返回结果，其他几种情况依然是阶段性处理，直到 868 行对 tasks 列表进行循环。如果一切顺利，会在这里做最后的处理，比如格式化元数据、保存文件、返回结果</p><p id="-cowyly_29">整个过程中，任务执行状态通过该任务对象的 <code class="code" id="-cowyly_74">yields</code> 属性不断更新。通过 <code class="code" id="-cowyly_75">callback</code> 函数，我们可以很清楚看到列表中的存储结构：</p><div class="code-block" data-lang="python">
def callback(step, x0, x, total_steps, y):
    done_steps = current_task_id * steps + step
    async_task.yields.append(['preview', (
        int(flags.preparation_step_count + (100 - flags.preparation_step_count) * float(done_steps) / float(all_steps)),
        f'Sampling step {step + 1}/{total_steps}, image {current_task_id + 1}/{image_number} ...', y)])
</div><p id="-cowyly_31">简单计算后会得出一个类似下边的列表 <code class="code" id="-cowyly_76">['preview', (60, 'Sample step 60/100, image 1/1 ...', y)]</code> ，这个列表中元素含义如下：</p><ul class="list _bullet" id="-cowyly_32"><li class="list__item" id="-cowyly_77"><p><code class="code" id="-cowyly_79">preview</code> ：这类似于是一个阶段标识，其本身可以提供的信息有限</p></li><li class="list__item" id="-cowyly_78"><p>元组： </p><ul class="list _bullet" id="-cowyly_80"><li class="list__item" id="-cowyly_81"><p>60：进度，这很容易理解，而且是总进度</p></li><li class="list__item" id="-cowyly_82"><p>'Sample step 60/100, image 1/1 ...'：进度的文字描述</p></li><li class="list__item" id="-cowyly_83"><p>y：这个是每一步的图像，也就是拿这个可以看到一个图像的生成过程</p></li></ul></li></ul></section><section class="chapter"><h2 id="thinking-when-reconstructing" data-toc="thinking-when-reconstructing">Thinking When Reconstructing</h2><p id="-cowyly_84">在 <a href="https://github.com/konieshadow" id="-cowyly_93" data-external="true" rel="noopener noreferrer">konieshadow</a> 创建的 <a href="https://github.com/mrhan1993/Fooocus-API" id="-cowyly_94" data-external="true" rel="noopener noreferrer">Fooocus-API</a> 项目中，他实现了一个新的任务队列，并基于 FastAPI 构建了新的任务对象，然后通过重写 <code class="code" id="-cowyly_95">async_worker.py</code> 的部分逻辑完成了对 Fooocus-API 的开发。</p><p id="-cowyly_85">但是在接手并维护该项目半年后，这种处理方式带来的问题变得越发难以处理，最主要的是下面两个问题：</p><ol class="list _decimal" id="-cowyly_86" type="1"><li class="list__item" id="-cowyly_96"><p>在应对 Fooocus 更新版本时，需要同步更新 <code class="code" id="-cowyly_98">async_worker.py</code> 中的代码，作为生成器，需要小心应对每一次变动</p></li><li class="list__item" id="-cowyly_97"><p>项目的启动是以启动一个 FastAPI 服务为前提的，这导致 Fooocus 中的前置启动逻辑无法被复用，需要重新实现，比如依赖的安装、环境检测、配置文件读取等，尽管可以通过简单的复制代码实现</p></li></ol><p id="-cowyly_87">此外，还有一些历史遗留的小问题，比如：</p><p id="-cowyly_88">无法和 WebUI 同时使用</p><p id="-cowyly_89">获取进度图需要请求单独的 EndPoint</p><p id="-cowyly_90">任务持久化信息保存不完整、返回数据格式不够统一</p><p id="-cowyly_91">基于以上问题，我决定对 Fooocus-API 进行重构，其思路如下：</p><ol class="list _decimal" id="-cowyly_92" type="1"><li class="list__item" id="-cowyly_99"><p>使用 <code class="code" id="-cowyly_102">async_worker.py</code> 中的任务处理逻辑，API 只负责接收参数并传递给任务处理逻辑</p></li><li class="list__item" id="-cowyly_100"><p>放弃单独维护的队列，复用 <code class="code" id="-cowyly_103">async_worker.py</code> 中的队列</p></li><li class="list__item" id="-cowyly_101"><p>合并接口功能，既然所有参数最终都是通过 <code class="code" id="-cowyly_104">async_worker.py</code> 中的 <code class="code" id="-cowyly_105">handler</code> 函数处理的，那么 API 只需要负责接收参数并传递即可，单独分离的接口是不必要的</p></li></ol></section><section class="chapter"><h2 id="how-about-fooocusapi-work" data-toc="how-about-fooocusapi-work">How about FooocusAPI work</h2><p id="-cowyly_106">基于上述逻辑，我重新设计了 FooocusAPI 的结构。</p><p id="-cowyly_107">首先，在 <code class="code" id="-cowyly_114">webui.py</code> 中增加一个方法，用来启动 API 服务，以及 WebUI，此时，我们可以同时使用 WebUI 和 API 服务</p><div class="code-block" data-lang="python">
def run_gradio():
    &quot;&quot;&quot;
    Run the gradio interface
    &quot;&quot;&quot;
    shared.gradio_root.launch(
        inbrowser=args_manager.args.in_browser,
        server_name=args_manager.args.listen,
        server_port=args_manager.args.port,
        share=args_manager.args.share,
        auth=check_auth if (args_manager.args.share or args_manager.args.listen) and auth_enabled else None,
        allowed_paths=[modules.config.path_outputs],
        blocked_paths=[constants.AUTH_FILENAME]
    )


if not args_manager.args.nowebui:
    Thread(target=run_gradio, daemon=True).start()
run_server(args_manager.args)
</div><p id="-cowyly_109">然后，将所有的参数放到一个模型 <code class="code" id="-cowyly_115">CommonRequest</code> 中。</p><p id="-cowyly_110">接下来，通过新增一个 <code class="code" id="-cowyly_116">pre_process</code> 方法，对参数进行预处理，比如保存文件、请求参数、以及一些必要的转换</p><p id="-cowyly_111">之后，通过 <code class="code" id="-cowyly_117">api_utils</code> 方法，将参数整理成 <code class="code" id="-cowyly_118">async_worker.py</code> 中的 <code class="code" id="-cowyly_119">handler</code> 方法需要的格式，将任务对象传递给 <code class="code" id="-cowyly_120">async_worker.py</code> 中的 <code class="code" id="-cowyly_121">worker</code> 方法</p><p id="-cowyly_112">最后，重写 <code class="code" id="-cowyly_122">call_worker</code> 方法，根据请求参数将不同的数据以不同的方式返回，在返回之前，任务对象会交由 <code class="code" id="-cowyly_123">post_worker</code> 做最后处理，比如保存结果、发送 Hook 信息等</p><p id="-cowyly_113">重构完成后，将最大限度保留原有的功能，同时，也使得 API 服务可以和 WebUI 共存，尽管由于对 Fooocus 中没有的功能如自定义放大倍数、Outpaint自定义的支持依然需要对 <code class="code" id="-cowyly_124">async_worker.py</code> 进行修改，但是，其修改量已经大大减少 同时，由于对 Fooocus 的修改非常有限，因此，在非大版本变动的情况下，对于 API 的维护成本也大大降低，对于追踪 Fooocus 的更新也更加方便，对于小幅度更新，只需要简单的合并上游的代码即可。</p></section><div class="last-modified">Last modified: 03 八月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="requirement.html" class="navigation-links__next">环境要求</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b408/app.js"></script></body></html>